localhost/index.html ==> localhost/
localhost/login.html ==> localhost/login/index.html (localhost/login)
localhost/user.html  ==> localhost/user/index.html (localhost/user)

js
js
js

1. Несколько страниц не могут обмениваться данными напрямую
server
localStorage

2. Время на перерисовку велико
при переключении страниц может быть заметно мигание

[SPA]
Single
Page
Application

# Идеологически
- Существует одна единая страница index.html с одной точкой входа в JS
  - *чтобы работал подход с единой точкой входа в приложение,
     нужно, чтобы сервер был настроен соответствующим образом
     и всегда редиректил на эту точку входа
 - Управление данными на себя берет JS
 - Управление отрисовкой всего DOM берет на себя JS

Пример:
- приложение, где есть фоновый плейбек
  - сервис воспроизведения музыки
  - библиотека с читалкой аудиокниг
  - видеохостинг
- сервис бронирования (отелей, билетов, апартаментов, автомобилей)
 - *на таком сервисе SPA имеет смысл делать для результатов поиска

# Технически
 1. Сервер всегда пуляет нас на одну и ту же страницу
 2. Страница запускает один и тот же JS
   - Скачивает данные
   - Обновляет UI страницы частично
 3. На странице живет некий кусок кода, который следит за изменениями
    в адресной строке:
   - Извлекает данные из адресной строки
   - Реагирует на изменения адреса и триггерит изменение UI

```
User Interactions (
  onChange,
  onClick,
  <A />, => не случается физического перехода, а происходит
            только изменение адресной строки
  <Form /> => не случается физического перехода
)
Состояние, которое управляет UI, который нужно отрисовывать хранится в адресной строке
UI, который нужно отрисовывать
```

# SPA
DOM => onChange => historyAPI => [штука реагирует и достает данные] => DOM

Штука, которая реагирует на изменения в адресной строке,
достает оттуда данные и умеет сама менять адресную строку
называется Router

# Технические нюансы
- Роутер знает на какой странице он инициализировался, из-за
  того, что он может прочитать `window.location` (pathname, search)

- При вызове `history.pushState` происходит событие `popstate` на
  которое может подписаться роутер

- Событие `popstate` работает не всегда, поэтому роутер предоставляет
  свои инструменты для изменения `history`

```ts
history.pushState(null, null, "/user");

const onPushState = [];

function pushState(url: string) {
  history.pushState(null, null, url);
  onPushState.forEach((cb) => cb(url));
}

// router.ts
onPushState.push(function(url) {
  // наша логика
});
```

# React Router
Если говорить о роутере в реакте, то роутинг сводится к тому, 
чтобы определить какое виртуальное DOM-дерево с каким стейтом
рисовать в зависимости от того, что указано в адресной строке

Чтобы не происходило физического перехода между страницами
при нажатии на ссылку или отправку формы, нам нужно перехватить
переход по ссылке и воспользоваться встроенной логикой роутера

```js
const a = document.querySelector("a");

a.onclick = function(evt) {
  evt.preventDefault();
  pushState(a.href);
}
```
